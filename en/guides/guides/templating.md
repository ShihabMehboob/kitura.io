---
### TRANSLATION INSTRUCTIONS FOR THIS SECTION:
### TRANSLATE THE VALUE OF THE title ATTRIBUTE AND UPDATE THE VALUE OF THE lang ATTRIBUTE.
### DO NOT CHANGE ANY OTHER TEXT.
layout: page
title: Templating
menu: resources
lang: en
redirect_from: "/resources/templating.html"
### END HEADER BLOCK - BEGIN GENERAL TRANSLATION
---

<div class="titleBlock">
	<h1>Using Templating Engines with Kitura</h1>
</div>

## Why use a template engine in your application?
A [template engine](https://en.wikipedia.org/wiki/Template_processor) allows rendering of documents using static templates. At runtime, template variables are substituted with actual values to generate an HTML file. This means that you have clear separation between your template and data. You can also generate multiple web pages dynamically with a single template!

---

## Kitura template engines
Kitura template engines are classes that implement the `TemplateEngine` protocol from the [Kitura-TemplateEngine package](https://github.com/IBM-Swift/Kitura-TemplateEngine/blob/master/Sources/KituraTemplateEngine/TemplateEngine.swift). Kitura currently supports three template engines, with Stencil being the most commonly used:

1. [Kitura-StencilTemplateEngine](https://github.com/IBM-Swift/Kitura-StencilTemplateEngine).
2. [Kitura-MustacheTemplateEngine](https://github.com/IBM-Swift/Kitura-MustacheTemplateEngine).
3. [Kitura-Markdown](https://github.com/IBM-Swift/Kitura-Markdown).

You can provide your own Kitura template engine by implementing the `TemplateEngine` protocol from [Kitura-TemplateEngine package](https://github.com/IBM-Swift/Kitura-TemplateEngine/blob/master/Sources/KituraTemplateEngine/TemplateEngine.swift).

---

## Setting up
See [Getting Started](/{{ page.lang }}/starter/gettingstarted.html) for instructions on how to install Kitura's command-line interface.

To use the template engines we first need to setup a Kitura server. Open a terminal and run the following:  
1. Create a directory  
`mkdir ~/KituraTemplateExample`
2. Change to the new directory  
`cd ~/KituraTemplateExample`
3. Create the Kitura server  
`kitura init`

`kitura init` downloads, creates and builds a starter Kitura application and will take a couple of minutes to complete. This includes best-practice implementations of health checking and monitoring as well as configuration files to allow easily deployment to a Docker container, a Kubernetes cluster, or the IBM Cloud.

## Adding a template engine to your Kitura app
Kitura is a lightweight, modular framework &mdash; by default you get basic HTTP functionality, like routing, parameter handling, parsing request body, etc. You can augment Kitura's out-of-the-box functionality by adding additional packages using the [Swift Package Manager](https://swift.org/package-manager/), or [SPM](https://swift.org/package-manager/) for short. The `kitura init` command we ran earlier created us a `Package.swift` file and added some of these packages for us already, we need to add two more. The two packages we'd like to add are the template engines we'd like to use:

* Kitura-StencilTemplateEngine  
```swift
.package(url: "https://github.com/IBM-Swift/Kitura-StencilTemplateEngine.git", .upToNextMajor(from: "1.0.0"))
```
* Kitura-MustacheTemplateEngine  
```swift
.package(url: "https://github.com/IBM-Swift/Kitura-MustacheTemplateEngine.git", .upToNextMajor(from: "1.0.0"))
```
### Adding the template engine packages
We're going to add both template engines to our Kitura app, to do this we need to add the packages to our `Package.swift` file (this was also generated by `kitura init`). In your terminal run the following:

1. Open the `Package.swift` file  
`open ~/KituraTemplateExample/Package.swift`

2. Add the packages to the list of dependencies, so below the line:
```swift
.package(url: "https://github.com/IBM-Swift/Health.git", from: "0.0.0"),
```
Add the following:  
```swift
.package(url: "https://github.com/IBM-Swift/Kitura-MustacheTemplateEngine.git", .upToNextMajor(from: "1.0.0")),
.package(url: "https://github.com/IBM-Swift/Kitura-StencilTemplateEngine.git", .upToNextMajor(from: "1.0.0")),
```

3. Add the template engines to the correct `target`. At the end of the line:  
```swift
.target(name: "Application", dependencies: [ "Kitura", "Configuration", "CloudEnvironment","SwiftMetrics","Health", ]),
```
Add `"KituraStencil", "KituraMustache"`  
The result should look like this:   
```swift
.target(name: "Application", dependencies: [ "Kitura", "Configuration", "CloudEnvironment","SwiftMetrics","Health", "KituraStencil", "KituraMustache"]),
```

After those changes our `Package.swift` should look like this:
```swift
// swift-tools-version:4.0
import PackageDescription

let package = Package(
    name: "KituraTemplateExample",
    dependencies: [
        .package(url: "https://github.com/IBM-Swift/Kitura.git", .upToNextMinor(from: "2.2.0")),
        .package(url: "https://github.com/IBM-Swift/HeliumLogger.git", .upToNextMinor(from: "1.7.1")),
        .package(url: "https://github.com/IBM-Swift/CloudEnvironment.git", .upToNextMinor(from: "6.0.0")),
        .package(url: "https://github.com/RuntimeTools/SwiftMetrics.git", from: "2.0.0"),
        .package(url: "https://github.com/IBM-Swift/Health.git", from: "0.0.0"),
        .package(url: "https://github.com/IBM-Swift/Kitura-MustacheTemplateEngine.git", from: "1.0.0"),
        .package(url: "https://github.com/IBM-Swift/Kitura-StencilTemplateEngine.git", from: "1.0.0"),
	],
	targets: [
      	    .target(name: "KituraTemplateExample", dependencies: [ .target(name: "Application"), "Kitura" , "HeliumLogger"]),
      	    .target(name: "Application", dependencies: [ "Kitura", "CloudEnvironment","SwiftMetrics","Health", "KituraStencil", "KituraMustache"]),

      	    .testTarget(name: "ApplicationTests" , dependencies: [.target(name: "Application"), "Kitura","HeliumLogger" ])
        ]
)
```

---

## Adding your template files to your Kitura app

### What are template files?
Template files are text files that follow the syntax of a template engine. Here is an example of a Mustache template, taken from [GRMustache.swift](https://github.com/groue/GRMustache.swift) and a Stencil template, taken from [Stencil](https://github.com/kylef/Stencil/blob/master/README.md).

`Mustache Example`:

{% raw %}
```
Hello {{name}}
Your beard trimmer will arrive on {{format(date)}}.
{{#late}}
Well, on {{format(realDate)}} because of a Martian attack.
{{/late}}
```
{% endraw %}

`Stencil Example`

{% raw %}
```
There are {{ articles.count }} articles.

{% for article in articles %}
  - {{ article.title }} by {{ article.author }}.
{% endfor %}
```
{% endraw %}

### Where do template files go?
By default template engines look in a `./Views` directory for the template files to use so we need to add this directory to our project. In a terminal window run the following:

`mkdir ~/KituraTemplateExample/Views`

### Adding the template files
We've added two new packages and a new directory to our project but if you open the `KituraTemplateExample.xcodeproj` that was generated by `kitura init` none of our additions will be visible within Xcode. To solve this we need to generate a new Xcode project so it will be aware of all we've added. Open a terminal and run the following:

1. Ensure you're in the correct directory    
`cd ~/KituraTemplateExample`

2. Generate new Xcode project  
`swift package generate-xcodeproj`

3. Once the command has finished executing open the new project  
`open KituraTemplateExample.xcodeproj`

Now we need to add our template files:

1. In Xcode right-click on the `Views` folder and select New File

2. Click on the new file (called `File` by default) and change the name to:
`StencilExample.stencil`

3. Add the following into the `StencilExample.stencil` file:  
{% raw %}
```
There are {{ articles.count }} articles.

{% for article in articles %}
  - {{ article.title }} by {{ article.author }}.
{% endfor %}
```
{% endraw %}

5. Create another new file in Views and change the name to:
`MustacheExample.mustache`

6. Add the following into the `MustacheExample.mustache` file:

{% raw %}
```
Hello {{name}}
Your beard trimmer will arrive on {{format(date)}}.
{{#late}}
Well, on {{format(realDate)}} because of a Martian attack.
{{/late}}
```
{% endraw %}

---

## Registering a template engine with a Router instance

We now have everything in place to start writing the code for our implementation of the template engines!  
In Xcode open the `Application.swift` file found in `Sources/Application/`

The first step we do to do is import our packages so we can make use of the API they provide. Below the line:
```swift
import Health
```

Add the following:
```swift
import KituraMustache
import KituraStencil
```
This will now allow us to use both of the template engines within our code.

> ![tip] You may need to build your project before you can import the template engines, this can be done in Xcode using `cmd + B`

To use the template engine, you must register it with a Router instance. This is done by calling the  `Router.add(templateEngine:)` function, e.g.:

In the `postInit()` function below the line:

```swift
initializeHealthRoutes(app: self)
```
Add the following
```swift
router.add(templateEngine: MustacheTemplateEngine())
router.add(templateEngine: StencilTemplateEngine())
```
We have now registered both of our template engines with a router.


---

## Rendering a template
We can render a template by calling the `response.render(_:context)` function, where context is the information the template engine will use to fill out the corresponding template files.

We will start with rendering the Stencil template. Below the line:  

```swift
router.add(templateEngine: StencilTemplateEngine())
```

add the following:
```swift
// Handle HTTP GET requests to Stencil
router.get("/articles") { request, response, next in

    // The example from https://github.com/kylef/Stencil/blob/master/README.md
    let context = [
       "articles": [
         ["title": "Migrating from OCUnit to XCTest", "author": "Kyle Fuller"],
         ["title": "Memory Management with ARC", "author": "Kyle Fuller" ]
       ]
    ]

    try response.render("StencilExample.stencil", context: context)
    next()
}
```

So lets break down what we're doing here;
First we've registered a GET end point which will call a block of code (a [closure](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)) when a GET request is made to the server:
`router.get("/articles") { request, response, next in ... }`

Then we create a context value, which is an array of dictionaries. The point to notice here is that the `key` for the context dictionary, i.e. the `"articles"` value matches the same value in our StencilExample.template:

{% raw %}
```
There are {{ articles.count }} articles.

{% for article in articles %}
  - {{ article.title }} by {{ article.author }}.
{% endfor %}
```
{% endraw %}

This is a requirement, the key for this dictionary HAS to match the corresponding value in your Stencil template file. This is how the template engine knows where to render the information we provide.  

We then call the render function, providing the name of the template file we want to use, `"StencilExample.stencil"`in this case, and the context. The render function will then use the context to fill out the template file and serve it to a specified URL, in our case this is: `https://localhost:8080`

Our `postInit()` function should look like this now:
```swift
func postInit() throws {
	// Endpoints
	initializeHealthRoutes(app: self)
	router.add(templateEngine: MustacheTemplateEngine())
	router.add(templateEngine: StencilTemplateEngine())

	router.get("/articles") { request, response, next in

	    let context = [
		"articles": [
		    ["title": "Migrating from OCUnit to XCTest", "author": "Kyle Fuller"],
		    ["title": "Memory Management with ARC", "author": "Kyle Fuller" ]
		]
	    ]

	    try response.render("StencilExample.stencil", context: context)
	    next()
	}
}
```


So now we're ready to see if our implementation of the Stencil template engine works, first we need to start our server. In Xcode we can just use the shortcut `cmd + R`.  
Allow the project to accept incoming network connections if prompted.

Then open:  

<a href="http://localhost:8080/articles" target="_blank"> http://localhost:8080/articles</a>  

and we should see this:  

```
There are 2 articles.


  - Migrating from OCUnit to XCTest by Kyle Fuller.

  - Memory Management with ARC by Kyle Fuller.
```

Next we will render the Mustache template, and we can do so along side our current Stencil implementation. Kitura allows multiple different template engines to be used along side each other.

First stop the current build running, in Xcode you can do this using the `cmd + .` shortcut. Next, below the previous `router.get("delivery") {...}` block add the following:

```swift
// Handle HTTP GET requests to GRMustache/
router.get("/delivery") { request, response, next in

    // The example from https://github.com/groue/GRMustache.swift/blob/master/README.md
    var context: [String: Any] = [
        "name": "Arthur",
        "date": Date(),
        "realDate": Date().addingTimeInterval(60*60*24*3),
        "late": true
    ]

    // Let template format dates with ``
    let dateFormatter = DateFormatter()
    dateFormatter.dateStyle = .medium
    context["format"] = dateFormatter

    try response.render("MustacheExample.mustache", context: context)
    next()
}
```

So again lets break down what we're doing here; we've set up another GET end point this time on the `"/delivery"` route. Just like in the Stencil example we create a `context` value, however this time we need to specify a type of `[String: Any]` because we're using multiple different types here. We can do this because the template engine is expecting a type of `[String: Any]` to be passed through. In our Stencil example the type of context was `[String: [String: String]]`, so the `[String: String]` would be the `Any` part here. The `context` contains values for Mustache's tags `name`, `date`, `realDate`, `late` and for GRMustache.swift's filter `format`

Our `postInit()` function should now look like this:

```swift
func postInit() throws {
        // Endpoints
        initializeHealthRoutes(app: self)
        router.add(templateEngine: MustacheTemplateEngine())
        router.add(templateEngine: StencilTemplateEngine())

	router.get("/articles") { request, response, next in

            let context = [
                "articles": [
                    ["title": "Migrating from OCUnit to XCTest", "author": "Kyle Fuller"],
                    ["title": "Memory Management with ARC", "author": "Kyle Fuller" ]
                ]
            ]

            try response.render("StencilExample.stencil", context: context)
            next()
        }

        router.get("/delivery") { request, response, next in

            var context: [String: Any] = [
                "name": "Arthur",
                "date": Date(),
                "realDate": Date().addingTimeInterval(60*60*24*3),
                "late": true
            ]

            let dateFormatter = DateFormatter()
            dateFormatter.dateStyle = .medium
            context["format"] = dateFormatter

            try response.render("MustacheExample.mustache", context: context)
            next()
        }

    }
```

Now if you run the project again using `cmd + R` and open  

<a href="http://localhost:8080/delivery" target="_blank"> http://localhost:8080/delivery</a>  

You should now see the following:  

```
> Hello Arthur
>
Your beard trimmer will arrive on Sep 8, 2016.
>
Well, on Sep 19, 2016 because of a Martian attack.
```

and if you open  

<a href="http://localhost:8080/articles" target="_blank"> http://localhost:8080/articles</a>  

you'll see that the Stencil implementation is still works and you should still see this:  

```
There are 2 articles.
>
>
  - Migrating from OCUnit to XCTest by Kyle Fuller.
>
  - Memory Management with ARC by Kyle Fuller.
```
Now we've implemented two different template engines which can work side by side!

---
## Useful extras
### Working with multiple template engines
As you can see from our example above you can use multiple different template engines in your Kitura app. The Router will know which template engine to use with a particular template file by the extension of the file.

For example, the extension for [Kitura-MustacheTemplateEngine](https://github.com/IBM-Swift/Kitura-MustacheTemplateEngine) is `.mustache` and the extension for [Kitura-StencilTemplateEngine](https://github.com/IBM-Swift/Kitura-StencilTemplateEngine) is `.stencil`.

The file extension of a template engine is defined by the `fileExtension` property of the [TemplateEngine protocol](https://github.com/IBM-Swift/Kitura-TemplateEngine/blob/master/Sources/KituraTemplateEngine/TemplateEngine.swift). For [Kitura-MustacheTemplateEngine](https://github.com/IBM-Swift/Kitura-MustacheTemplateEngine) and [Kitura-StencilTemplateEngine](https://github.com/IBM-Swift/Kitura-StencilTemplateEngine) we can edit this `fileExtension` property when we register the template engines to the router:
```swift
router.add(templateEngine: StencilTemplateEngine(), forFileExtensions: ["myExtension"], useDefaultFileExtension: false)
```
Now we need to make sure our Stencil template file has the correct extension: `StencilExample.myExtension` rather then `StencilExample.stencil` and ensure we're passing this through to our render function:  
```swift
try response.render("StencilExample.myExtension", context: context)
```

So we've looked at creating a custom file extension for our Stencil template engine, but what if we also changed the Mustache file extension to the same file extension as the Stencil template engine? Well lets take a look at what happens:

```swift
router.add(templateEngine: StencilTemplateEngine(), forFileExtensions: ["myExtension"], useDefaultFileExtension: false)
router.add(templateEngine: MustacheTemplateEngine(), forFileExtensions: ["myExtension"], useDefaultFileExtension: false)
```
So we've created a custom file extension for each template engine that's identical and we've registered both of these template engines to the same router. All we need to do now is update the render function call inside the GET handler for the Mustache template engine:
```swift
try response.render("MustacheExample.myExtension", context: context)
```

Now run the project (`cmd + R`) and open:  

<a href="http://localhost:8080/delivery" target="_blank"> http://localhost:8080/delivery</a>  

and:  

<a href="http://localhost:8080/articles" target="_blank"> http://localhost:8080/articles</a>  


You'll notice the Stencil template (`/articles`) hasn't been rendered correctly but the Mustache template (`/delivery`) has been rendered correctly, so what's happening here?

It's relating to the order in which we registered our template engines, we registered the Mustache template last and this is why the Mustache template is rendered, if we swap the order:
```swift
router.add(templateEngine: MustacheTemplateEngine(), forFileExtensions: ["myExtension"], useDefaultFileExtension: false)
router.add(templateEngine: StencilTemplateEngine(), forFileExtensions: ["myExtension"], useDefaultFileExtension: false)
```

and rerun the project (cmd + R) and again open:  

<a href="http://localhost:8080/delivery" target="_blank"> http://localhost:8080/delivery</a>  

and:  

<a href="http://localhost:8080/articles" target="_blank"> http://localhost:8080/articles</a>  

This time the Stencil template (`/articles`) has been rendered correctly but the Mustache template (`/delivery`) hasn't. So it's important to note that if you're using different template engines and assigning custom file extensions that it's best to use different file extensions for each template engine to avoid unexpected behaviour.

---

### Setting the default template engine
You can set the default template engine for a Router instance in order to save specifying the template file extensions of that template engine.

So in our example if we set the Mustache template engine as the default:
```swift
router.setDefault(templateEngine: MustacheTemplateEngine())
```

We can then call the render function without having to supply the file extension:
```swift
response.render("MustacheExample", context: context).
```

This does not affect the usage of multiple different template engines, you can still use the Stencil template engine by supplying the extension for that:
```swift
response.render("StencilExample.stencil", context: context).
```

### Changing where template files go
As mentioned in our example template engines expect template files to exist in a `./Views` directory. You can change this default location using the `viewsPath` variable. This is a property of the `Router` instance, so will affect all template engines registered to this particular `Router`. Lets look at an example.

So first working with the example above, we need to create a new directory. Open a terminal and run the following:

1. Change to correct directory  
`cd ~/Desktop/KituraTemplateExample`
2. Make new directory
`mkdir Templates`
3. Copy template to new directory
`cp ./Views/StencilExample.stencil ./Templates`
3. Regenerate project
`swift package generate-xcodeproj`
4. Open Xcode project
`open KituraTemplateExample.xcodeproj`

Now we need to update our `viewsPath` property, so below the line:
```swift
router.add(templateEngine: StencilTemplateEngine())
```
Add the following:
```swift
router.viewsPath = "./Templates"
```
Now run the project (`cmd + R`) and open:  

<a href="http://localhost:8080/articles" target="_blank"> http://localhost:8080/articles</a>  

We should see our correctly rendered template:
```
There are 2 articles.
>
>
  - Migrating from OCUnit to XCTest by Kyle Fuller.
>
  - Memory Management with ARC by Kyle Fuller.
```

And if we open:  

<a href="http://localhost:8080/delivery" target="_blank"> http://localhost:8080/delivery</a>  

We should see that this template hasn't been rendered as it still exists in the old location, the `./Views` directory. To have this render correctly we'd just need to move it to the new `./Templates` directory.

### Additional Resources

If you'd like to see a Stencil template engine in use in an iOS app checkout our [FoodTrackerBackend](https://github.com/IBM/FoodTrackerBackend/blob/master/StencilFrontend.md) tutorial!
<section class="social-section">
	<div class="social-link">
		<a rel="nofollow" href="http://swift-at-ibm-slack.mybluemix.net">
		<img src="https://developer.ibm.com/swift/wp-content/uploads/sites/69/2018/01/slack-150x150.png" alt="Slack Logo" width="60" height="60" class="social-image"/></a>
		<p class="social-header">Join the discussion on Slack</p>
	</div>
	<div  class="social-link">
		<iframe class="social-image" src="https://ghbtns.com/github-btn.html?user=IBM-Swift&amp;repo=Kitura&amp;type=star&amp;count=true&amp;size=large" frameborder="0" scrolling="0" width="150px" height="30px"></iframe>
		<p class="social-header">Star Kitura on GitHub</p>
	</div>
</section>
[info]: ../../../assets/info-blue.png
[tip]: ../../../assets/lightbulb-yellow.png
[warning]: ../../../assets/warning-red.png
